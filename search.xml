<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[èšç±»ç®—æ³•ä¹‹meanShift]]></title>
    <url>%2F2019%2F05%2F14%2F%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E4%B9%8BmeanShift%2F</url>
    <content type="text"><![CDATA[å‰è¨€åœ¨å¼€å§‹Meanshiftä¹‹å‰éœ€è¦å…ˆå¼„æ‡‚K-meansï¼Œå› ä¸ºK-meansçš„ç¼ºç‚¹ï¼ˆéœ€è¦äº‹å…ˆè®¾ç½®æ—çš„æ•°é‡Kï¼Œå’Œèµ·å§‹æ—ä¸­å¿ƒï¼‰ï¼Œå¯æ˜¯å¤§å¤šæ—¶å€™ï¼Œäººå·¥å¹¶ä¸èƒ½å®Œç¾Žçš„è®¾ç½®Kå’Œèµ·å§‹ä¸­å¿ƒï¼Œå°±ä¼šå¯¼è‡´ï¼Œæœ¬æ¥å¯ä»¥èšæˆ5ç±»çš„ï¼Œç»“æžœåªèšæˆ4ç±»ç­‰ä¸€ç³»åˆ—é—®é¢˜ã€‚è€ŒMeanShiftï¼ˆå‡å€¼æ¼‚ç§»ï¼‰è§£å†³äº†è¿™äº›é—®é¢˜. MeanShiftç®—æ˜¯å¯¹K-meansçš„ä¸€ç§æ”¹è¿›ã€‚é¦–å…ˆä¸éœ€è¦äº‹å…ˆè¾“å…¥Kï¼Œè€Œæ˜¯æ ¹æ®æ—å¿ƒæ¼‚ç§»ï¼Œè‡ªåŠ¨èšé›†å‡ºKç±»ï¼›å¦å¤–ï¼ŒåŸºäºŽå¯ä»¥æ¼‚ç§»è‡ªåŠ¨èšç±»ï¼Œé‚£ä¹ˆèµ·å§‹æ—å¿ƒä¹Ÿä¸éœ€è¦æå‰è¾“å…¥ï¼Œå¯ä»¥æ‹¿æ•°æ®ä¸­æ‰€æœ‰çš„å…ƒç´ ä½œä¸ºèµ·å§‹æ—å¿ƒï¼ˆåªæ˜¯ä¼šå¢žåŠ è¿‡é‡è®¡ç®—ï¼Œè¿™ç¯‡ä¸­æˆ‘ä¼šåšæ•°æ®ç²—ç²’åŒ–å¤„ç†ï¼Œæ¥å‡å°‘è¿‡é‡è®¡ç®—ï¼‰ ç®—æ³•æ ¸å¿ƒæ€æƒ³å¯¹äºŽæ‰€æœ‰èµ·å§‹æ—å¿ƒï¼Œè®¡ç®—å…¶è§„å®šçƒå†…æ‰€æœ‰å…ƒç´ çš„å‡å€¼ä½œä¸ºä¸‹ä¸€ä¸ªæ—å¿ƒï¼Œå½“å‰æ—å¿ƒåˆ°æ–°çš„æ—å¿ƒçš„å‘é‡å«åšåç§»å‘é‡ã€‚ æ–°çš„å‡å€¼æ—å¿ƒè®¡ç®—å‡½æ•°ï¼š â€‹ ä¸Šå¼é»˜è®¤ä¸ºçƒå†…æ¯ä¸ªå…ƒç´ æƒé‡ä¸€æ ·ã€‚ é‚£ä¹ˆä»Žtæ—¶åˆ»åˆ°t+1æ—¶åˆ»å‡å€¼ä¸­å¿ƒçš„åç§»å‘é‡ä¸ºï¼š è€Œåœ¨MeanShiftèšç±»è¿‡ç¨‹ä¸­ä¸ºäº†åŠ å¿«æ”¶æ•›ï¼Œå¼•å…¥äº†å’Œå‡½æ•°]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AntAlgorithm(èšç¾¤ç®—æ³•)]]></title>
    <url>%2F2019%2F05%2F06%2F%E8%9A%82%E8%9A%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[â€‹ åœ¨æˆ‘å®Œå…¨æžæ˜Žç™½èš‚èšç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä¹Ÿåœ¨ç½‘ä¸Šæ‰¾äº†å¥½å¤šèµ„æ–™ï¼Œæ¯ä¸ªéƒ½çœ‹å®Œï¼Œéƒ½æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼Œå°±æ˜¯ï¼Œä¸ç®¡è°çš„blogæˆ–è€…è®ºæ–‡ï¼Œéƒ½æ˜¯ä¼šæ”¾ä¸Šä¸‰ä¸ªæ•°å­¦å…¬å¼ï¼Œæˆ–è€…å†åŠ ä¸Šä¸€æ®µå¯¹åº”æ•°å­¦å…¬å¼çš„ä»£ç ã€‚å¯¹äºŽéžä¸“ç§‘ç”Ÿæ¥è¯´éžå¸¸å¤´ç–¼ã€‚è¿™é‡Œæˆ‘æŒ‰ç…§æˆ‘çš„ç†è§£é€šä¿—çš„åˆ†äº«ä¸€ä¸‹ã€‚ #æ ¸å¿ƒæ€è·¯ â€‹ æœ¬ç®—æ³•çš„åŽŸç†æ˜¯æ¨¡ä»¿èš‚èšåœ¨è‡ªç„¶ç•Œçš„è¡Œä¸ºï¼Œä½†æ˜¯åˆæœ‰ç‚¹ä¸åŒã€‚èš‚èšåœ¨è¡Œå¾„çš„è·¯é€”ä¸­ä¼šé‡Šæ”¾æ¿€ç´ ï¼Œä»¥ä¾¿äºŽè‡ªå·±æ´»ç€å…¶ä»–èš‚èšæ‰¾åˆ°èµ°è¿‡çš„è·¯å¾„ï¼Œæ¿€ç´ æ˜¯æœ‰æŒ¥å‘æ€§çš„ï¼Œæ—¶é—´è¶Šä¹…æ¿€ç´ çš„æµ“åº¦å°±ä¼šè¶Šä½Žï¼Œè¢«è¯†åˆ«çš„æ¦‚çŽ‡è¶Šä½Žã€‚ï¼ˆè¿™ä¹Ÿæ˜¯ç®—æ³•çš„ç¡¬æ ¸æ‰€åœ¨ï¼‰ã€‚æ‰€ä»¥åœ¨ç®—æ³•ä¸­ï¼Œæ¯ä¸ªèš‚èšæ²¡è·‘å®Œä¸€æ¬¡è·¯å¾„æ‰€æºå¸¦çš„ä¿¡æ¯ç´ æ€»é‡æ˜¯ä¸€å®šçš„ï¼Œè·¯å¾„è¶Šé•¿ï¼Œé‚£ä¹ˆå•ä½è·¯å¾„ä¸Šçš„ä¿¡æ¯ç´ å°±è¶Šå°‘ï¼Œè¢«é‡å¤é€‰æ‹©ä¸ªæ¦‚çŽ‡å°±è¶Šå°ï¼Œè€Œè¢«æ·˜æ±°ã€‚å¦å¤–ä¿¡æ¯ç´ åœ¨è·¯ä¸Šå¯ä»¥ç´¯åŠ çš„ï¼Œä½†æ˜¯ä¼šéšæ„é—´æŒ¥å‘ï¼Œæ‰€æœ‰çš„è¿™äº›å½±å“å› ç´ æ…¢æ…¢çš„å åŠ ï¼Œæœ€ç»ˆå°±å¯ä»¥é€‰æ‹©å‡ºæœ€çŸ­è·¯å¾„ã€‚ #æ•°å­¦æ¨¡åž‹ â€‹ ä¸€ï¼‰ã€ç¬¬ä¸€ä¸ªæ•°å­¦æ¨¡åž‹å‡½æ•°ï¼Œä¸‹ä¸€ä¸ªåŸŽå¸‚é€‰æ‹©æ¦‚çŽ‡å‡½æ•°ï¼š è¿™ä¸ªæ•°å­¦å…¬å¼çš„æ„æ€æ˜¯ï¼Œå½“å‰åœ¨åœ° i ä¸ªåŸŽå¸‚ï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚ j çš„æ¦‚çŽ‡ï¼ˆjä»£è¡¨æ‰€æœ‰åŸŽå¸‚ä¸­éž i çš„åŸŽå¸‚ï¼‰ã€‚ ##åˆ†å­ï¼š å‰åŠéƒ¨åˆ†ï¼š è¡¨ç¤ºåŸŽå¸‚ iï¼Œj ä¹‹é—´çš„ä¿¡æ¯å› ç´ ï¼ˆæ‰€æœ‰èš‚èšåœ¨åŸŽå¸‚ iï¼Œj ä¹‹é—´ç•™ä¸‹çš„ä¿¡æ¯ç´ æ€»å’Œï¼Œå³ä¿¡æ¯æµ“åº¦ï¼‰ åŽåŠéƒ¨åˆ†ï¼š è¡¨ç¤ºåŸŽå¸‚ iï¼Œj ä¹‹é—´çš„è·ç¦»è·ç¦»å› ç´ ï¼ˆé»˜è®¤ä¸ºè·ç¦»çš„å€’æ•°ï¼‰ ##åˆ†æ¯ï¼š è¡¨ç¤ºå½“å‰åŸŽå¸‚ i åˆ°æ‰€æœ‰å¯ä»¥åˆ°è¾¾çš„åŸŽå¸‚çš„ ä¿¡æ¯å› ç´ ä¸Žè·ç¦»å› ç´ ä¹˜æœºçš„åŠ å’Œã€‚ è¿™ä¸€æ­¥æˆ‘ä»¬çŸ¥é“äº†ä»Žå½“å‰åŸŽå¸‚åˆ°æ¯ä¸€ä¸ªåŸŽå¸‚çš„æ¦‚çŽ‡ï¼Œé‚£ä¹ˆæŽ¥ä¸‹æ¥å°±æ˜¯æŒ‰ç…§æ¦‚çŽ‡æ¥é€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚ã€‚è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨è½®ç›˜ç®—æ³•ï¼ˆä¹Ÿå¯ä»¥ç”¨numpy.choise(target, size, p)æ¥é€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚ï¼‰ é€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚çš„ä»£ç å—ï¼š 123456789101112131415161718192021222324252627282930313233343536373839def __choice_next_city(self): # åˆå§‹åŒ–è½¬ç§»æ¦‚çŽ‡çŸ©é˜µï¼ˆä»Žå½“å‰åŸŽå¸‚åˆ°æ¯ä¸€ä¸ªåŸŽå¸‚çš„æ¦‚çŽ‡ï¼‰ cities_prob = np.zeros(shape=(city_num,)) # cities_prob = list(cities_prob) # å°†numpyçŸ©é˜µè½¬æ¢æˆlist total_prob = 0.0 # ç”¨æ¦‚çŽ‡å‡½æ•°è®¡ç®—æ¦‚çŽ‡çŸ©é˜µ(è”æƒ³é€‰è·¯æ¦‚çŽ‡å‡½æ•°) for next_city in range(city_num): if self.callable_city[next_city]: try: # cities_prob[next_city] = np.power( # pheromone_graph[self.current_city][next_city], ALPHA) * np.power(1.0 / distance_graph[self.current_city][next_city], BATA) cities_prob[next_city] = pow( pheromone_graph[self.current_city][next_city], ALPHA) * pow(1.0 / distance_graph[self.current_city][next_city], BATA) total_prob += cities_prob[next_city] except ZeroDivisionError as e: print( f"Ant ID: &#123;self.ID&#125;, current city: &#123;self.current_city&#125;, target city: &#123;next_city&#125;") sys.exit(1) # é€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚ ï¼ˆè²Œä¼¼ç”¨è½®ç›˜ç®—æ³•æ¯”ç”¨numpyå¿«ï¼‰ # next_city = np.random.choice(np.arange(city_num), size=1, p=cities_prob / float(total_prob)) # è½®ç›˜ç®—æ³• next_city = None if total_prob &gt; 0: temp_prob = random.uniform(0.0, total_prob) for i in range(city_num): if self.callable_city[i]: temp_prob -= cities_prob[i] if temp_prob &lt; 0.0: next_city = i break # ç¬¬ä¸€ä¸ªå¾ªçŽ¯çš„æ—¶å€™ï¼Œåªèƒ½éšæœºé€‰æ‹© if not next_city: next_city = random.randint(0, city_num - 1) while not self.callable_city[next_city]: next_city = random.randint(0, city_num - 1) return next_city â€‹ äºŒï¼‰ã€ä»ŽåŸŽå¸‚çš„é€‰æ‹©æ¦‚çŽ‡å‡½æ•°å¯ä»¥çœ‹åˆ°ï¼Œæœ‰ä¸¤ä¸ªå½±å“å› ç´ ï¼Œä¸€ä¸ªæ˜¯è·ç¦»å› ç´ ï¼Œè¿™ä¸ªæ²¡ä¸¤ä¸ªåŸŽå¸‚ä¹‹é—´æ˜¯å›ºå®šçš„ã€‚å¦å¤–ä¸€ä¸ªå°±æ˜¯ä¿¡æ¯æµ“åº¦ï¼ŒÏ„(i,j).ä¿¡æ¯æµ“åº¦ä¼šåœ¨æ¯åªèš‚èšç»è¿‡ä¹‹åŽå¢žåŠ ï¼Œå¦å¤–ï¼Œä¿¡æ¯ä¹Ÿä¼šéšç€æ—¶é—´ä¼šå‘ï¼Œæ‰€ä»¥ä¿¡æ¯æµ“åº¦ä¼šæœ‰ä¸€ä¸ªæ›´æ–°å‡½æ•°ï¼š ç¬¬ä¸€ä¸ªå‡½æ•°è¡¨ç¤º iï¼Œ jä¸¤ä¸ªåŸŽå¸‚ä¹‹é—´çš„ä¿¡æ¯æµ“åº¦ä»Žtæ—¶åˆ»åˆ°t+1æ—¶åˆ»åŽ Ï è¡¨ç¤ºä¿¡æ¯ç´ çš„æŒ¥å‘é€Ÿåº¦ã€‚âˆ‡Ï„(i,j)è¡¨ç¤ºæ‰€æœ‰çš„èš‚èšåœ¨ iï¼Œj ä¹‹é—´ç•™ä¸‹çš„ä¿¡æ¯ç´ ä¹‹å’Œã€‚Î´Ï„(ij)è¡¨ç¤ºæ¯åªèš‚èšåœ¨ iï¼Œj ä¸¤ä¸ªåŸŽå¸‚ä¹‹é—´ç•™ä¸‹çš„ä¿¡æ¯ç´ ã€‚ ä¿¡æ¯æµ“åº¦æ›´æ–°ä»£ç ï¼š 1234567891011121314151617def __uodate_pheromone_graph(self): """æ›´æ–°ä¿¡æ¯ç´ """ # åˆå§‹åŒ–èš‚èšæœ¬è½®é‡Šæ”¾çš„ä¿¡æ¯çŸ©é˜µï¼ˆæ¯åªèš‚èšçš„ä¿¡æ¯ç´ éƒ½éœ€è¦åŠ è¿›æ¥ï¼‰: ç›¸å½“äºŽè®¡ç®— â–³Tij temp_pheromone = np.zeros((city_num, city_num)) # temp_pheromone = list(temp_pheromone) # å°†numpyçŸ©é˜µè½¬æ¢æˆlist for ant in self.ants: # å°†æ‰€æœ‰èš‚èšåœ¨è·¯å¾„ä¸Šç•™ä¸‹çš„ä¿¡æ¯ç´ å åŠ  for i in range(1, city_num): start, end = ant.path[i - 1], ant.path[i] # è¿™é‡Œç”¨åˆ°èš‚èšä¿¡æ¯ç´ é‡Šæ”¾æ¨¡åž‹å‡½æ•° temp_pheromone[start][end] += Q / ant.total_distance temp_pheromone[end][start] = temp_pheromone[start][end] # æ›´æ–°ä¿¡æ¯ç´ çŸ©é˜µ (ç”¨åˆ°ä¿¡æ¯ç´ æµ“åº¦æ›´æ–°å‡½æ•°) for i in range(city_num): for j in range(city_num): pheromone_graph[i][j] = pheromone_graph[i][j] * \ RHO + temp_pheromone[i][j] ä¸‰ï¼‰ã€åœ¨ç¬¬äºŒæ­¥ä¿¡æ¯æµ“åº¦æ›´æ–°å‡½æ•°çš„ç¬¬äºŒä¸ªå‡½æ•°ä¸­ï¼Œè¿˜æœ‰ä¸€ä¸ªæœªè§£å†³çš„å˜é‡Î´Ï„(ij)ã€‚æ‰€æœ‰è¿™é‡Œæ¶‰åŠåˆ°ç¬¬ä¸‰ä¸ªå‡½æ•°æ¨¡åž‹ï¼šèš‚èšä¿¡æ¯ç´ é‡Šæ”¾æ¨¡åž‹ï¼š Qæ˜¯å¸¸é‡å‚æ•°ï¼ˆä¸€èˆ¬è®¾ç½®ä¸º1ã€10ã€100ç­‰ï¼‰ï¼Œè¡¨ç¤ºæ¯åªèš‚èšä¸€æ¬¡å¾ªçŽ¯é‡Šæ”¾çš„ä¿¡æ¯æ€»é‡ï¼›Lè¡¨ç¤ºæ¯åªèš‚èšå½“æ¬¡å®Œæ•´è·¯çº¿çš„æ€»è·ç¦»ã€‚ å› ä¸ºQæ˜¯å®šå€¼ï¼Œæ‰€ä»¥å½“èš‚èšçš„è·¯çº¿æ€»è·¯ç¨‹Lè¶ŠçŸ­çš„æ—¶å€™é‡Šæ”¾çš„ä¿¡æ¯ç´ Î´Ï„(ij)å°±ä¼šè¶Šå¤§ï¼Œå¯¹äºŽä¿¡æ¯ç´ æµ“åº¦æ¥è¯´ï¼Œå½“t+1æ—¶åˆ»ï¼Œå°±ä¼šæœ‰æ›´å¤§çš„âˆ‡Ï„(i,j)ï¼Œå’Œæ›´å¤§çš„ä¿¡æ¯æµ“åº¦Ï„(i,j)ï¼Œæ‰€ä»¥åœ¨t+1æ—¶åˆ»ï¼Œè¢«é€‰æ‹©çš„æ¦‚çŽ‡å°±ä¼šæ›´å¤§ï¼Œä»¥è¿™æ ·ä¸€æ¬¡ä¸€æ¬¡å åŠ ï¼Œæœ€ç»ˆé€‰æ‹©å‡ºæ¥æœ€çŸ­çš„è·¯å¾„ã€‚ æ•´ä¸ªç®—æ³•çš„æ ¸å¿ƒæµç¨‹åˆå§‹åŒ–èš‚èšç§ç¾¤ã€‚å¼€å§‹è·‘ç¬¬ä¸€ä¸ªå¾ªçŽ¯ï¼ˆç¬¬ä¸€ä¸ªå¾ªçŽ¯çš„æ—¶å€™ï¼Œè·¯å¾„ä¸Šæ²¡æœ‰åŽ†å²ä¿¡æ¯ç´ ï¼Œæ‰€ä»¥ç¬¬ä¸€è½®çš„æ—¶å€™æ¯åªèš‚èšéƒ½æ˜¯éšæœºé€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚ï¼‰ï¼Œç¬¬ä¸€æ¬¡å¾ªçŽ¯å®ŒæˆåŽï¼Œéœ€è¦è®¡ç®—æ¯åªèš‚èšçš„æ€»è·¯ç¨‹ã€è®¡ç®—æ¯åªèš‚èšçš„ä¿¡æ¯é‡Šæ”¾é‡ï¼Œæ›´æ–°æ‰€æœ‰åŸŽå¸‚ä¹‹é—´çš„ä¿¡æ¯æµ“åº¦ï¼›æŽ¥ç€è·‘ç¬¬äºŒè½®ï¼Œç¬¬äºŒè½®å¾€åŽï¼Œæ¯æ¬¡é€‰æ‹©ä¸‹ä¸€ä¸ªåŸŽå¸‚çš„æ¦‚çŽ‡å°±ä¼šäº§ç”Ÿå·®å¼‚ï¼Œç„¶åŽé‡å¤ç¬¬ä¸€è½®æ‰€éœ€è¦åšçš„æ‰€æœ‰æ›´æ–°ã€‚ å®Œæˆä»£ç ä¼ é€é—¨ï¼ˆgithubï¼‰ï¼šhttps://github.com/RoryXiang/MCL_dairy/blob/master/AG/AGTSP.py æœ€åŽé™„ä¸Šä¸€ç¯‡å…³äºŽèš‚èšç®—æ³•ä¸­å„ä¸ªå‚æ•°çš„å½±å“çš„è®ºæ–‡ï¼š é“¾æŽ¥:https://pan.baidu.com/s/1UWv0Q3oboc22R8B5VRvmSw å¯†ç :lnp8 ä¸‹ä¸€ç¯‡å‡†å¤‡èŠ±ç‚¹æ—¶é—´çœ‹çœ‹æ‰€æœ‰çš„èšç±»ç®—æ³•ç„¶åŽåˆ†äº«ä¸€ä¸‹ã€‚]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeneticAlgorithm(é—ä¼ ç®—æ³•)]]></title>
    <url>%2F2019%2F04%2F12%2FGeneticAlgorithm%2F</url>
    <content type="text"><![CDATA[â€‹ ç¬¬ä¸€ç¯‡å†™é—ä¼ ç®—æ³•ï¼Œä¸€æ˜¯å› ä¸ºæˆ‘æŽ¥è§¦ç¬¬ä¸€ä¸ªç®—æ³•ï¼Œå¦å¤–å°±æ˜¯å®ƒçš„ç”¨é€”å¾ˆå¹¿ï¼Œå¾ˆå¤šæ–¹å‘éƒ½èƒ½ç”¨åˆ°ã€‚ä¸€èˆ¬éƒ½ç”¨åœ¨è§£å†³ï¼šå‡½æ•°æœ€å€¼é—®é¢˜ã€TSPï¼ˆæ—…è¡Œå•†é—®é¢˜ï¼‰ã€èƒŒåŒ…é—®é¢˜ç­‰ç­‰ã€‚ â€‹ é—ä¼ ç®—æ³•å®Œå…¨çš„æ¨¡æ‹Ÿç”Ÿç‰©çš„é—ä¼ è¿‡ç¨‹ï¼Œæ‰€ä»¥ç®—æ³•çš„æ ¸å¿ƒä¹Ÿæ˜¯å¯ä»¥ç”¨ç”Ÿç‰©çš„é—ä¼ è¿‡ç¨‹æ¥ç†è§£ï¼šé—ä¼ å’Œå˜å¼‚ðŸ§¬ï¼Œé€‚è€…ç”Ÿå­˜ï¼ˆé€‰æ‹©ä¼˜èƒœè€…ï¼‰ã€‚ç®—æ³•çš„éš¾ç‚¹ä¹Ÿæ˜¯åœ¨å®žé™…ä¸šåŠ¡æˆ–è€…ä½¿ç”¨ä¸­ï¼Œå¦‚ä½•å°†å®žé™…é—®é¢˜è½¬åŒ–æˆæ•°å­¦æ¨¡åž‹ä¸­çš„æ¨¡åž‹ã€‚ å¼€å§‹ç¬¬ä¸€ä¸ªdemoï¼ˆè§£å†³TSPé—®é¢˜ï¼Œæ±‚æœ€çŸ­è·¯å¾„ï¼‰ï¼šâ€‹ ä»¥20ä¸ªåŸŽå¸‚ä¸¾ä¾‹ï¼Œæ‰¾å‡ºè€…20ä¸ªåŸŽå¸‚çš„æœ€çŸ­è·¯å¾„ã€‚ â€‹ é—ä¼ ç®—æ³•åœ¨è§£å†³è¿™ä¸ªé—®é¢˜çš„æ—¶å€™ï¼Œæ ¸å¿ƒæ˜¯ï¼šé—ä¼ ã€å˜å¼‚å‡½æ•°ï¼Œè¿™é‡Œæˆ‘ä»¬é‡‡ç”¨çš„æ˜¯ä¸€éƒ¨åˆ†åŸºå› æ¥è‡ªçˆ¶äº²ï¼Œä¸€éƒ¨åˆ†æ¥è‡ªæ¯äº²ï¼Œä¾‹å¦‚ï¼Œfather = [1, 4, 5, 2, 3], motner = [2, 4, 3, 5, 1] åˆ™å­©å­å¯èƒ½ä¸º [1, 4, 3, 2, 5],å‰åŠéƒ¨åˆ†åŸºå› æ¥è‡ªçˆ¶äº²ï¼ŒåŽåŠéƒ¨åˆ†æ¥è‡ªæ¯äº²ï¼Œé¡ºåºéƒ½éœ€è¦ä¿æŒçˆ¶æ¯çš„ã€‚å˜å¼‚å‘¢ï¼Œåˆ™æ˜¯ï¼Œéšæœºæ›´æ¢ä»»æ„ä¸¤ä¸ªä½ç½®çš„åŸŽå¸‚ä¸º[1, 4, 1,5, 2, 3], 5, 3æ¢ä½ç½®ã€‚ äº¤å‰å‡½æ•°ï¼ˆç”Ÿå­©å­çš„è¿‡ç¨‹ï¼‰12345678910111213141516171819202122232425def crossover(self, father, people): """äº¤å‰é…å¯¹å‡½æ•°ã€‚åŽŸç†æ˜¯ï¼Œé€‰æ‹©çˆ¶äº²çš„ä¸€éƒ¨åˆ†åŸŽå¸‚æŽ’åºï¼Œç„¶åŽå‰©ä½™çš„åŸŽå¸‚æŽ’åºæŒ‰ç…§æ¯äº²çš„æŽ’åºæ–¹å¼ç»„åˆæˆå­©å­è·¯çº¿æ–¹æ¡ˆ Arguments: father [city1,city2..] -- æ‰€æœ‰çš„åŸŽå¸‚æŽ’åº people [[city1,city2..],[city4,city10..]] -- æ‰€æœ‰çš„è·¯çº¿æ–¹æ¡ˆ Returns: [city1,city2..] -- ç”Ÿæˆçš„å­©å­è·¯çº¿æ–¹æ¡ˆæˆ–è€…çˆ¶äº²è·¯çº¿ """ if np.random.rand() &lt; self.cross_rate: # ä»Žpeopleä¸­é€‰æ‹©å¦ä¸€ä¸ªparent mother_index = np.random.randint(0, self.people_size, size=1) # é€‰æ‹©äº¤å‰çš„DNAä¸‹æ ‡ cross_points = np.random.randint(0, 2, self.DNA_size, dtype=np.bool) # é€‰æ‹©fatheréƒ¨åˆ†çš„åŸŽå¸‚ï¼ˆæŽ’åºæ–¹å¼ä¸ºfatherå·²æœ‰çš„æŽ’åºï¼‰ father_city = father[cross_points] # é€‰æ‹©fatheræ²¡é€‰ä¸Šçš„åŸŽå¸‚ï¼ˆæŽ’åºæ–¹å¼ä¸ºmotherä»¥åŽçš„æŽ’åºï¼‰ mother_city = people[mother_index, np.isin( people[mother_index].ravel(), father_city, invert=True)] child = np.concatenate((father_city, mother_city)) # time.sleep(10) # father[:] = np.concatenate((father_city, mother_city)) # return father return child return father å˜å¼‚å‡½æ•°1234567891011121314def mutate(self, child): """å˜å¼‚å‡½æ•°ã€‚æ¯ä¸ªåŸŽå¸‚éƒ½æœ‰å‡ çŽ‡äº§ç”Ÿå˜å¼‚ã€‚å˜å¼‚ï¼šéšæœºä¸Žè·¯çº¿ä¸Šçš„å¦å¤–ä¸€ä¸ªåŸŽå¸‚äº¤æ¢ä½ç½® Arguments: child [int] -- è·¯çº¿æ–¹æ¡ˆ Returns: child [int] -- è·¯çº¿æ–¹æ¡ˆ """ for point_index in range(self.DNA_size): if np.random.rand() &lt; self.mutation_rate: swap_point_index = np.random.randint(0, self.DNA_size) swap_A, swap_B = child[point_index], child[swap_point_index] child[point_index], child[swap_point_index] = swap_B, swap_A return child å®Œæˆäº†é—ä¼ å˜å¼‚çš„è¿‡ç¨‹ï¼Œç”Ÿç‰©ç§ç¾¤å°±ä¼šå¢žå¤šï¼ŒæŽ¥ä¸‹æ¥å°±æ˜¯é€‚è€…ç”Ÿå­˜ï¼Œæ‹©ä¼˜çš„è¿‡ç¨‹ã€‚ä½†æ˜¯åœ¨åšé€‰æ‹©çš„æ—¶å€™ï¼Œéœ€è¦æœ‰ä¸€ä¸ªé€‰æ‹©æ ‡å‡†æ¥åˆ¤æ–­é‚£ä¸ªä¸ªä½“æ›´é€‚åˆã€‚åœ¨è§£å†³TSPï¼Œé‚£ä¹ˆæ¯ä¸ªä¸ªä½“çš„è·¯çº¿é•¿çŸ­åˆ™ä½œä¸ºåˆ¤æ–­ä¾æ®ï¼ˆè·¯çº¿çŸ­çš„ä¼˜èƒœï¼‰ã€‚è¿™é‡Œå°±éœ€è¦ä¸€ä¸ªè®¡ç®—é€‚åº”æ€§çš„å‡½æ•°ã€‚ é€‚åº”æ€§è®¡ç®—å‡½æ•°12345678910111213141516171819def get_fitness(self, xs_values, ys_values): """è®¡ç®—æ¯æ¡è·¯çº¿çš„è·ç¦»distanceï¼Œå¹¶ä¸”ä»¥è·ç¦»çš„å€’æ•°ä¸ºeçš„æŒ‡æ•°çš„å€¼ä½œä¸ºfitness Arguments: xs_values [[float]]-- æ‰€æœ‰è·¯çº¿çš„xåæ ‡åˆ—è¡¨ ys_values [[float]]-- æ‰€æœ‰è·¯çº¿çš„yåæ ‡åˆ—è¡¨ Returns: fitness [float] -- æ¯æ¡è·¯çº¿çš„é€‚åº”æ€§ total_distance [float] -- æ¯æ¡è·¯çº¿çš„è·ç¦» """ total_distance = np.empty((xs_values.shape[0], ), dtype=np.float64) for index, (x_values, y_values) in enumerate(zip(xs_values, ys_values)): total_distance[index] = np.sum( np.sqrt(np.square(np.diff(x_values)) + np.square(np.diff(y_values)))) fitness = np.exp(self.DNA_size * 2 / total_distance) # è¿™é‡Œä¸ºä»€ä¹ˆè¦ä¹˜ä»¥self.DNA_size * 2ï¼Œå› ä¸ºåŸºæ•°å¤ªå°ï¼Œfitnessä¹‹é—´å·®è·å¤ªå°ï¼Œåœ¨åšselectçš„æ—¶å€™å°±ä¼šæ¯ä¸ªæ¦‚çŽ‡å‡ ä¹Žç›¸ç­‰äº†ï¼Œæ”¶æ•›å¤ªæ…¢ï¼Œæ”¾å¤§åŽæ¦‚çŽ‡å·®å°±æ›´å‡¸æ˜¾ # fitness1 = np.exp(1 / total_distance) # print("???????", fitness, fitness1) return fitness, total_distance é€‰æ‹©å‡½æ•°è¿™ä¸ªé€‰æ‹©å‡½æ•°çš„æ€æƒ³æ˜¯ï¼Œä»Žç§ç¾¤ä¸­é€‰æ‹©æ–°çš„ç§ç¾¤ï¼Œæ¯ä¸ªä¸ªä½“éƒ½å¯ä»¥è¢«é‡å¤é€‰æ‹©ï¼Œä½†æ˜¯é€‚åº”æ€§é«˜çš„ä¸ªä½“è¢«é‡å¤é€‰æ‹©çš„æ¦‚çŽ‡é«˜ï¼Œé€‚åº”æ€§ä½Žçš„ä¸ªä½“ï¼Œå¯èƒ½ä¸€æ¬¡éƒ½é€‰ä¸ä¸Šï¼Œreplace=Trueè¡¨ç¤ºå¯è¢«é‡å¤é€‰æ‹©ï¼Œp=fitness / fitness.sum()è¡¨ç¤ºæ¯ä¸ªä¸ªä½“çš„é€‰æ‹©æ¦‚çŽ‡ 123456def select(self, fitness): """é€‰æ‹©å‡½æ•° """ index = np.random.choice(np.arange( self.people_size), size=self.people_size, replace=True, p=fitness / fitness.sum()) return self.people[index] è¿›åŒ–å‡½æ•°å½“å‰ç§ç¾¤çš„ä¸€æ¬¡è¿›åŒ–ï¼Œå…ˆæ ¹æ®é€‚åº”æ€§é€‰æ‹©æ–°çš„ç§ç¾¤ï¼Œç„¶åŽåœ¨å¯¹æ¯ä¸ªä¸ªä½“è¿›è¡Œäº¤å‰é—ä¼ å¹¶å¯¹é—ä¼ çš„æ–°ä¸ªä½“äº§ç”Ÿå˜å¼‚ 12345678910111213def evolve(self, fitness): """è¿›åŒ–å‡½æ•°ï¼ˆä¸€æ¬¡è¿›åŒ–ï¼‰ Arguments: fitness &#123;[type]&#125; -- [description] """ people = self.select(fitness) people_copy = people.copy() for father in people: child = self.crossover(father, people_copy) child = self.mutate(child) # father[:] = child father = child self.people = people æ•´ä¸ªæ±‚è§£çš„æµç¨‹é¦–å…ˆåˆå§‹åŒ–ä¸€ä¸ªç”Ÿç‰©ç§ç¾¤ï¼š 12ga = GA(DNA_size=CITY_NUM, cross_rate=CROSS_RATE, mutation_rate=MUTATION_RATE, people_size=POP_SIZE) # åˆå§‹åŒ–ç§ç¾¤ åˆå§‹åŒ–20ä¸ªåŸŽå¸‚: 1env = TSP(city_num=CITY_NUM) # åˆå§‹åŒ–20æ˜¯ä¸ªåŸŽå¸‚ ç„¶åŽæ ¹æ®å®šä¹‰çš„é—ä¼ ä»£æ•°æ¥é€ä»£è¿›åŒ– 123456789101112for generation in range(N_GENERATION): # è®¡ç®—å‡ºæ‰€æœ‰ä¸ªä½“çš„åæ ‡ x_values, y_values = ga.translate_DNA(ga.people, env.city_position) # è®¡ç®—å‡ºæ‰€æœ‰ä¸ªä½“çš„é€‚åº”æ€§+è·¯ç¨‹ fitness, total_distance = ga.get_fitness(x_values, y_values) # é—ä¼ æ¼”å˜ ga.evolve(fitness) # æ‰¾å‡ºé€‚åº”æ€§æœ€é«˜çš„ä¸ªä½“ best_idx = np.argmax(fitness) print('Gen:', generation, '| best fit: %.2f' % fitness[best_idx],) env.ploting(x_values[best_idx], y_values[best_idx], total_distance[best_idx]) å®Œæ•´ä»£ç ä¼ é€é—¨ï¼š https://github.com/RoryXiang/MCL_dairy/blob/master/GeneticAlgorithm/shortest_path.py ä¸‹ä¸€ç¯‡æ˜¯èš‚èšç®—æ³•æ¥è§£å†³TSP]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>æœºå™¨å­¦ä¹ </tag>
      </tags>
  </entry>
</search>
