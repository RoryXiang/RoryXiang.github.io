<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AntAlgorithm(蚂蚁算法)]]></title>
    <url>%2F2019%2F05%2F06%2F%E8%9A%82%E8%9A%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 在我完全搞明白蚂蚁算法之前，我也在网上找了好多资料，每个都看完，都有一个特点，就是，不管谁的blog或者论文，都是会放上三个数学公式，活着再加上一段对应数学公式的代码。对于非专科生来说非常头疼。这里我按照我的理解通俗的分享一下。 ###核心思路 ​ 本算法的原理是模仿蚂蚁在自然界的行为，但是又有点不同。蚂蚁在行径的路途中会释放激素，以便于自己活着其他蚂蚁找到走过的路径，但是，激素是有挥发性的，时间越久激素的浓度就会越低，被识别的概率越低。（这也是算法的硬核所在）。所以在算法中，每个蚂蚁没跑完一次路径所携带的信息素总量是一定的，路径越长，那么单位路径上的信息素就越少，被重复选择个概率就越小，而被淘汰。另外信息素在路上可以累加的，但是会随意间挥发，所有的这些影响因素满满的叠加，最终就可以选择出最短路径。 ###数学模型 ​ 第一个数学模型函数，下一个城市选择概率函数： 这个数学公式的意思是，当前在地 i 个城市，选择下一个城市 j 的概率（j代表所有城市中非 i 的城市）。 分子： 表示城市 i，j 之间的信息因子（所有蚂蚁在城市 i，j 之间留下的信息素总和） 表示城市 i，j 之间的距离距离因子（默认为距离的倒数） 分母：表示当前城市 i 到所有可以到达的城市的 信息因素与距离因素乘机的加和。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeneticAlgorithm(遗传算法)]]></title>
    <url>%2F2019%2F04%2F12%2FGeneticAlgorithm%2F</url>
    <content type="text"><![CDATA[​ 第一篇写遗传算法，一是因为我接触第一个算法，另外就是它的用途很广，很多方向都能用到。一般都用在解决：函数最值问题、TSP（旅行商问题）、背包问题等等。 ​ 遗传算法完全的模拟生物的遗传过程，所以算法的核心也是可以用生物的遗传过程来理解：遗传和变异🧬，适者生存（选择优胜者）。算法的难点也是在实际业务或者使用中，如何将实际问题转化成数学模型中的模型。 开始第一个demo（解决TSP问题，求最短路径）：​ 以20个城市举例，找出者20个城市的最短路径。 ​ 遗传算法在解决这个问题的时候，核心是：遗传、变异函数，这里我们采用的是一部分基因来自父亲，一部分来自母亲，例如，father = [1, 4, 5, 2, 3], motner = [2, 4, 3, 5, 1] 则孩子可能为 [1, 4, 3, 2, 5],前半部分基因来自父亲，后半部分来自母亲，顺序都需要保持父母的。变异呢，则是，随机更换任意两个位置的城市为[1, 4, 1,5, 2, 3], 5, 3换位置。 交叉函数（生孩子的过程）12345678910111213141516171819202122232425def crossover(self, father, people): """交叉配对函数。原理是，选择父亲的一部分城市排序，然后剩余的城市排序按照母亲的排序方式组合成孩子路线方案 Arguments: father [city1,city2..] -- 所有的城市排序 people [[city1,city2..],[city4,city10..]] -- 所有的路线方案 Returns: [city1,city2..] -- 生成的孩子路线方案或者父亲路线 """ if np.random.rand() &lt; self.cross_rate: # 从people中选择另一个parent mother_index = np.random.randint(0, self.people_size, size=1) # 选择交叉的DNA下标 cross_points = np.random.randint(0, 2, self.DNA_size, dtype=np.bool) # 选择father部分的城市（排序方式为father已有的排序） father_city = father[cross_points] # 选择father没选上的城市（排序方式为mother以后的排序） mother_city = people[mother_index, np.isin( people[mother_index].ravel(), father_city, invert=True)] child = np.concatenate((father_city, mother_city)) # time.sleep(10) # father[:] = np.concatenate((father_city, mother_city)) # return father return child return father 变异函数1234567891011121314def mutate(self, child): """变异函数。每个城市都有几率产生变异。变异：随机与路线上的另外一个城市交换位置 Arguments: child [int] -- 路线方案 Returns: child [int] -- 路线方案 """ for point_index in range(self.DNA_size): if np.random.rand() &lt; self.mutation_rate: swap_point_index = np.random.randint(0, self.DNA_size) swap_A, swap_B = child[point_index], child[swap_point_index] child[point_index], child[swap_point_index] = swap_B, swap_A return child 完成了遗传变异的过程，生物种群就会增多，接下来就是适者生存，择优的过程。但是在做选择的时候，需要有一个选择标准来判断那个个体更适合。在解决TSP，那么每个个体的路线长短则作为判断依据（路线短的优胜）。这里就需要一个计算适应性的函数。 适应性计算函数12345678910111213141516171819def get_fitness(self, xs_values, ys_values): """计算每条路线的距离distance，并且以距离的倒数为e的指数的值作为fitness Arguments: xs_values [[float]]-- 所有路线的x坐标列表 ys_values [[float]]-- 所有路线的y坐标列表 Returns: fitness [float] -- 每条路线的适应性 total_distance [float] -- 每条路线的距离 """ total_distance = np.empty((xs_values.shape[0], ), dtype=np.float64) for index, (x_values, y_values) in enumerate(zip(xs_values, ys_values)): total_distance[index] = np.sum( np.sqrt(np.square(np.diff(x_values)) + np.square(np.diff(y_values)))) fitness = np.exp(self.DNA_size * 2 / total_distance) # 这里为什么要乘以self.DNA_size * 2，因为基数太小，fitness之间差距太小，在做select的时候就会每个概率几乎相等了，收敛太慢，放大后概率差就更凸显 # fitness1 = np.exp(1 / total_distance) # print("???????", fitness, fitness1) return fitness, total_distance 选择函数这个选择函数的思想是，从种群中选择新的种群，每个个体都可以被重复选择，但是适应性高的个体被重复选择的概率高，适应性低的个体，可能一次都选不上，replace=True表示可被重复选择，p=fitness / fitness.sum()表示每个个体的选择概率 123456def select(self, fitness): """选择函数 """ index = np.random.choice(np.arange( self.people_size), size=self.people_size, replace=True, p=fitness / fitness.sum()) return self.people[index] 进化函数当前种群的一次进化，先根据适应性选择新的种群，然后在对每个个体进行交叉遗传并对遗传的新个体产生变异 12345678910111213def evolve(self, fitness): """进化函数（一次进化） Arguments: fitness &#123;[type]&#125; -- [description] """ people = self.select(fitness) people_copy = people.copy() for father in people: child = self.crossover(father, people_copy) child = self.mutate(child) # father[:] = child father = child self.people = people 整个求解的流程首先初始化一个生物种群： 12ga = GA(DNA_size=CITY_NUM, cross_rate=CROSS_RATE, mutation_rate=MUTATION_RATE, people_size=POP_SIZE) # 初始化种群 初始化20个城市: 1env = TSP(city_num=CITY_NUM) # 初始化20是个城市 然后根据定义的遗传代数来逐代进化 123456789101112for generation in range(N_GENERATION): # 计算出所有个体的坐标 x_values, y_values = ga.translate_DNA(ga.people, env.city_position) # 计算出所有个体的适应性+路程 fitness, total_distance = ga.get_fitness(x_values, y_values) # 遗传演变 ga.evolve(fitness) # 找出适应性最高的个体 best_idx = np.argmax(fitness) print('Gen:', generation, '| best fit: %.2f' % fitness[best_idx],) env.ploting(x_values[best_idx], y_values[best_idx], total_distance[best_idx]) 完整代码传送门： https://github.com/RoryXiang/MCL_dairy/blob/master/GeneticAlgorithm/shortest_path.py 下一篇是蚂蚁算法来解决TSP]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
